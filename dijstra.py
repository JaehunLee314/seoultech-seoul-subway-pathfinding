import pandas as pd, glob, os, re
from collections import defaultdict
import heapq

# 1) 1í˜¸ì„ 
line1_stations = {
    "trunk": [
        "ì†Œìš”ì‚°","ë™ë‘ì²œ","ë³´ì‚°","ë™ë‘ì²œì¤‘ì•™","ì§€í–‰","ë•ì •","ë•ê³„","ì–‘ì£¼","ë…¹ì–‘","ê°€ëŠ¥","ì˜ì •ë¶€",
        "íšŒë£¡","ë§ì›”ì‚¬","ë„ë´‰ì‚°","ë„ë´‰","ë°©í•™","ì°½ë™","ë…¹ì²œ","ì›”ê³„","ì„±ë¶","ì„ê³„","ì‹ ì´ë¬¸",
        "ì™¸ëŒ€ì•ž","íšŒê¸°","ì²­ëŸ‰ë¦¬","ì œê¸°ë™","ì‹ ì„¤ë™","ë™ë¬˜ì•ž","ë™ëŒ€ë¬¸","ì¢…ë¡œ5ê°€","ì¢…ë¡œ3ê°€","ì¢…ê°",
        "ì‹œì²­","ì„œìš¸ì—­","ë‚¨ì˜","ìš©ì‚°","ë…¸ëŸ‰ì§„","ëŒ€ë°©","ì‹ ê¸¸","ì˜ë“±í¬","ì‹ ë„ë¦¼","êµ¬ë¡œ",
        "ê°€ì‚°ë””ì§€í„¸ë‹¨ì§€","ë…ì‚°","ê¸ˆì²œêµ¬ì²­","ì„ìˆ˜","ê´€ì•…","ì•ˆì–‘","ëª…í•™","ê¸ˆì •","êµ°í¬","ë‹¹ì •",
        "ì˜ì™•","ì„±ê· ê´€ëŒ€","í™”ì„œ","ìˆ˜ì›","ì„¸ë¥˜","ë³‘ì ","ì„¸ë§ˆ","ì˜¤ì‚°ëŒ€","ì˜¤ì‚°","ì§„ìœ„","ì†¡íƒ„",
        "ì„œì •ë¦¬","ì§€ì œ","í‰íƒ","ì„±í™˜","ì§ì‚°","ë‘ì •","ì²œì•ˆ","ë´‰ëª…","ìŒìš©","ì•„ì‚°","ë°°ë°©",
        "ì˜¨ì–‘ì˜¨ì²œ","ì‹ ì°½"
    ],
    "incheon_branch": [ # êµ¬ë¡œ : ë¶„ê¸°ì  ì—°ê²° ìœ„í•´ í¬í•¨
        "êµ¬ë¡œ","êµ¬ì¼","ê°œë´‰","ì˜¤ë¥˜ë™","ì˜¨ìˆ˜","ì—­ê³¡","ì†Œì‚¬","ë¶€ì²œ","ì¤‘ë™","ì†¡ë‚´","ë¶€ê°œ",
        "ë¶€í‰","ë°±ìš´","ë™ì•”","ê°„ì„","ì£¼ì•ˆ","ë„í™”","ì œë¬¼í¬","ë„ì›","ë™ì¸ì²œ","ì¸ì²œ"
    ],
    "gwangmyeong_branch": ["ê¸ˆì²œêµ¬ì²­","ê´‘ëª…"], # ê¸ˆì²­êµ¬ì²­ : ë¶„ê¸°ì  ì—°ê²° ìœ„í•´ í¬í•¨
    "seodongtan_branch": ["ë³‘ì ","ì„¸ë§ˆ","ì„œë™íƒ„"] # ë³‘ì  : ë¶„ê¸°ì  ì—°ê²° ìœ„í•´ í¬í•¨
}

# 2) 2í˜¸ì„ 
line2_stations = {
    "main_loop": [
        "ì‹œì²­","ì„ì§€ë¡œìž…êµ¬","ì„ì§€ë¡œ3ê°€","ì„ì§€ë¡œ4ê°€","ë™ëŒ€ë¬¸ì—­ì‚¬ë¬¸í™”ê³µì›","ì‹ ë‹¹","ìƒì™•ì‹­ë¦¬",
        "ì™•ì‹­ë¦¬","í•œì–‘ëŒ€","ëšì„¬","ì„±ìˆ˜","ê±´ëŒ€ìž…êµ¬","êµ¬ì˜","ê°•ë³€","ìž ì‹¤ë‚˜ë£¨","ìž ì‹¤","ìž ì‹¤ìƒˆë‚´",
        "ì¢…í•©ìš´ë™ìž¥","ì‚¼ì„±","ì„ ë¦‰","ì—­ì‚¼","ê°•ë‚¨","êµëŒ€","ì„œì´ˆ","ë°©ë°°","ì‚¬ë‹¹","ë‚™ì„±ëŒ€",
        "ì„œìš¸ëŒ€ìž…êµ¬","ë´‰ì²œ","ì‹ ë¦¼","ì‹ ëŒ€ë°©","êµ¬ë¡œë””ì§€í„¸ë‹¨ì§€","ëŒ€ë¦¼","ì‹ ë„ë¦¼","ë¬¸ëž˜",
        "ì˜ë“±í¬êµ¬ì²­","ë‹¹ì‚°","í•©ì •","í™ëŒ€ìž…êµ¬","ì‹ ì´Œ","ì´ëŒ€","ì•„í˜„","ì¶©ì •ë¡œ"
    ],
    "seongsu_branch": ["ì„±ìˆ˜","ìš©ë‹µ","ì‹ ë‹µ","ìš©ë‘","ì‹ ì„¤ë™"],
    "sinjeong_branch": ["ì‹ ë„ë¦¼","ë„ë¦¼ì²œ","ì–‘ì²œêµ¬ì²­","ì‹ ì •ë„¤ê±°ë¦¬","ê¹Œì¹˜ì‚°"],
}

# 3) 3í˜¸ì„ 
line3_stations = [
    "ëŒ€í™”","ì£¼ì—½","ì •ë°œì‚°","ë§ˆë‘","ë°±ì„","ëŒ€ê³¡","í™”ì •","ì›ë‹¹","ì›í¥","ì‚¼ì†¡","ì§€ì¶•","êµ¬íŒŒë°œ",
    "ì—°ì‹ ë‚´","ë¶ˆê´‘","ë…¹ë²ˆ","í™ì œ","ë¬´ì•…ìž¬","ë…ë¦½ë¬¸","ê²½ë³µê¶","ì•ˆêµ­","ì¢…ë¡œ3ê°€","ì„ì§€ë¡œ3ê°€",
    "ì¶©ë¬´ë¡œ","ë™ëŒ€ìž…êµ¬","ì•½ìˆ˜","ê¸ˆí˜¸","ì˜¥ìˆ˜","ì••êµ¬ì •","ì‹ ì‚¬","ìž ì›","ê³ ì†í„°ë¯¸ë„","êµëŒ€",
    "ë‚¨ë¶€í„°ë¯¸ë„","ì–‘ìž¬","ë§¤ë´‰","ë„ê³¡","ëŒ€ì¹˜","í•™ì—¬ìš¸","ëŒ€ì²­","ì¼ì›","ìˆ˜ì„œ","ê°€ë½ì‹œìž¥",
    "ê²½ì°°ë³‘ì›","ì˜¤ê¸ˆ"
]

# 4) 4í˜¸ì„ 
line4_stations = [
    "ë‹¹ê³ ê°œ","ìƒê³„","ë…¸ì›","ì°½ë™","ìŒë¬¸","ìˆ˜ìœ ","ë¯¸ì•„","ë¯¸ì•„ì‚¬ê±°ë¦¬","ê¸¸ìŒ","ì„±ì‹ ì—¬ëŒ€ìž…êµ¬",
    "í•œì„±ëŒ€ìž…êµ¬","í˜œí™”","ë™ëŒ€ë¬¸","ë™ëŒ€ë¬¸ì—­ì‚¬ë¬¸í™”ê³µì›","ì¶©ë¬´ë¡œ","ëª…ë™","íšŒí˜„","ì„œìš¸ì—­",
    "ìˆ™ëŒ€ìž…êµ¬","ì‚¼ê°ì§€","ì‹ ìš©ì‚°","ì´ì´Œ","ë™ìž‘","ì´ìˆ˜","ì‚¬ë‹¹","ë‚¨íƒœë ¹","ì„ ë°”ìœ„","ê²½ë§ˆê³µì›",
    "ëŒ€ê³µì›","ê³¼ì²œ","ì •ë¶€ê³¼ì²œì²­ì‚¬","ì¸ë•ì›","í‰ì´Œ","ë²”ê³„","ê¸ˆì •","ì‚°ë³¸","ìˆ˜ë¦¬ì‚°","ëŒ€ì•¼ë¯¸",
    "ë°˜ì›”","ìƒë¡ìˆ˜","í•œëŒ€ì•ž","ì¤‘ì•™","ê³ ìž”","ì´ˆì§€","ì•ˆì‚°","ì‹ ê¸¸ì˜¨ì²œ","ì •ì™•","ì˜¤ì´ë„"
]

# 5) 5í˜¸ì„ 
line5_stations = {
    "main_line": [
        "ë°©í™”","ê°œí™”ì‚°","ê¹€í¬ê³µí•­","ì†¡ì •","ë§ˆê³¡","ë°œì‚°","ìš°ìž¥ì‚°","í™”ê³¡","ê¹Œì¹˜ì‚°","ì‹ ì •","ëª©ë™",
        "ì˜¤ëª©êµ","ì–‘í‰","ì˜ë“±í¬êµ¬ì²­","ì˜ë“±í¬ì‹œìž¥","ì‹ ê¸¸","ì—¬ì˜ë„","ì—¬ì˜ë‚˜ë£¨","ë§ˆí¬","ê³µë•","ì• ì˜¤ê°œ",
        "ì¶©ì •ë¡œ","ì„œëŒ€ë¬¸","ê´‘í™”ë¬¸","ì¢…ë¡œ3ê°€","ì„ì§€ë¡œ4ê°€","ë™ëŒ€ë¬¸ì—­ì‚¬ë¬¸í™”ê³µì›","ì²­êµ¬","ì‹ ê¸ˆí˜¸",
        "í–‰ë‹¹","ì™•ì‹­ë¦¬","ë§ˆìž¥","ë‹µì‹­ë¦¬","ìž¥í•œí‰","êµ°ìž","ì•„ì°¨ì‚°","ê´‘ë‚˜ë£¨","ì²œí˜¸","ê°•ë™",
        "ê¸¸ë™","êµ½ì€ë‹¤ë¦¬","ëª…ì¼","ê³ ë•","ìƒì¼ë™", "ê°•ì¼", "ë¯¸ì‚¬", "í•˜ë‚¨í’ì‚°", "í•˜ë‚¨ì‹œì²­", "í•˜ë‚¨ê²€ë‹¨ì‚°"
    ],
    "macheon_branch": ["ê°•ë™","ë‘”ì´Œë™","ì˜¬ë¦¼í”½ê³µì›","ë°©ì´","ì˜¤ê¸ˆ","ê°œë¡±","ê±°ì—¬","ë§ˆì²œ"]
}

# -----------------------------
# 1. 2~5í˜¸ì„ (ë‹¨ì„ ) ë¦¬ìŠ¤íŠ¸ëŠ” ê·¸ëŒ€ë¡œ
# -----------------------------
lines = {
    1: line1_stations,
    2: line2_stations,
    3: line3_stations,
    4: line4_stations,
    5: line5_stations
}

# ------------------------------------------------------------
# 0)  CSV â†’ run_times  ë¡œë”©
# ------------------------------------------------------------
def _parse_mmss(time_str: str) -> float:
    """'1:30' â†’ 1.5  (ë¶„ ë‹¨ìœ„ float)"""
    m, s = map(int, time_str.split(':'))
    return m + s / 60

def load_run_times_csv(folder: str = 'ì—­ê°„ì†Œìš”ì‹œê°„(ìˆ˜ìž‘ì—…)') -> dict:
    """í´ë” ì•ˆ *.csv ëª¨ë‘ ì½ì–´ (ì—­1, ì—­2) â†” ë¶„  dict ë°˜í™˜"""
    run = {}
    for path in glob.glob(os.path.join(folder, '*.csv')):
        df = pd.read_csv(path, encoding='UTF-8')
        prev = None
        for _, row in df.iterrows():
            cur = row['ì—­ëª…'].strip()
            if pd.isna(row['ì‹œê°„(ë¶„)']):
                continue
            if prev is not None:
                t = _parse_mmss(str(row['ì‹œê°„(ë¶„)']))
                run[(prev, cur)] = t
                run[(cur, prev)] = t   # ì—­ë°©í–¥ ë™ì¼
            prev = cur
    return run

def edge_time(graph, u, v, default=0):
    """graph[u] ë¦¬ìŠ¤íŠ¸ì—ì„œ v ë¡œ ê°€ëŠ” ê°€ì¤‘ì¹˜ë¥¼ ì°¾ì•„ ë°˜í™˜"""
    for w, nbr in graph[u]:
        if nbr == v:
            return w
    return default

RUN_TIMES = load_run_times_csv('ì—­ê°„ì†Œìš”ì‹œê°„(ìˆ˜ìž‘ì—…)')   # â† ì—…ë¡œë“œí•œ CSV ê²½ë¡œ

# ------------------------------------------------------------
# 1)  ê·¸ëž˜í”„ ìƒì„± : run-times ìš°ì„  ì‚¬ìš©
# ------------------------------------------------------------
DEFAULT_TRAVEL = 2      # run_times ì— ì—†ëŠ” êµ¬ê°„ fallback
TRANSFER_TIME  = 4      # â†” í™˜ìŠ¹ íŽ˜ë„í‹° (ì›í•˜ë©´ ì¡°ì •)

def build_graph(lines_dict, run_tbl):
    graph = defaultdict(list)

    def add_edge(a, b, w):
        graph[a].append((w, b))
        graph[b].append((w, a))

    for ln, data in lines_dict.items():
        segments = data.values() if isinstance(data, dict) else [data]

        for key, seg in (data.items() if isinstance(data, dict) else [("linear", data)]):
            for s1, s2 in zip(seg, seg[1:]):
                w = run_tbl.get((s1, s2), run_tbl.get((s2, s1), DEFAULT_TRAVEL))
                add_edge((ln, s1), (ln, s2), w)
            if key.endswith("_loop"):                # ì›í˜• Loop ë§ˆì§€ë§‰â†”ì²«
                w = run_tbl.get((seg[-1], seg[0]), run_tbl.get((seg[0], seg[-1]), DEFAULT_TRAVEL))
                add_edge((ln, seg[-1]), (ln, seg[0]), w)

    # ===== í™˜ìŠ¹ ê°„ì„  =====
    station_to_lines = defaultdict(list)
    for ln, data in lines_dict.items():
        all_st = (st for seg in data.values() for st in seg) if isinstance(data, dict) else data
        for st in all_st:
            station_to_lines[st].append(ln)

    for st, lns in station_to_lines.items():
        for i in range(len(lns)):
            for j in range(i + 1, len(lns)):
                add_edge((lns[i], st), (lns[j], st), TRANSFER_TIME)

    return graph
# -------------------------------------------------------------
# constants & helpers
# -------------------------------------------------------------
def parse_node(token: str):
    """
    '2,ê°•ë‚¨' â†’ (2, 'ê°•ë‚¨')
    ê³µë°± ìžë™ ì œê±°, í•œê¸€Â·ì˜ë¬¸ ì—­ëª… ëª¨ë‘ OK
    """
    line_str, station = map(str.strip, token.split(','))
    return int(line_str), station
# -------------------------------------------------------------
# 3. ì¤€ë¹„: build_graph(lines) ëŠ” ê·¸ëŒ€ë¡œ
# -------------------------------------------------------------
graph = build_graph(lines, RUN_TIMES)   # ðŸ‘ˆ ì´ì œ ì‹¤ì‹œê°„ ë°˜ì˜

# ðŸ”‘  station â†’ [(line, station)]   ì—­ ì´ë¦„ì„ ë…¸ë“œ ë¦¬ìŠ¤íŠ¸ë¡œ ë§¤í•‘
station_to_nodes = defaultdict(list)
for node in graph.keys():                 # graph ì— ì¡´ìž¬í•˜ëŠ” ëª¨ë“  ë…¸ë“œ
    ln, st = node
    station_to_nodes[st].append(node)

# -------------------------------------------------------------
# 4. ë‹¤ì¤‘ ì¶œë°œ/ë„ì°© ì§€ì› Dijkstra
# -------------------------------------------------------------
def dijkstra_multi(graph, start_name, goal_name):
    if start_name not in station_to_nodes:
        raise ValueError(f"ì¶œë°œì—­ '{start_name}' ì´(ê°€) ë…¸ì„  ë°ì´í„°ì— ì—†ìŠµë‹ˆë‹¤.")
    if goal_name   not in station_to_nodes:
        raise ValueError(f"ë„ì°©ì—­ '{goal_name}' ì´(ê°€) ë…¸ì„  ë°ì´í„°ì— ì—†ìŠµë‹ˆë‹¤.")

    # (1) ìŠˆí¼ ì†ŒìŠ¤ ì¶”ê°€: ë…¸ë“œ IDëŠ” ('S', '') ë¡œ ìž„ì‹œ ì‚¬ìš©
    SUPER = ('S', '')
    for n in station_to_nodes[start_name]:
        graph[SUPER].append((0, n))   # ê°€ì¤‘ì¹˜ 0 ê°„ì„ 

    # (2) ëª©ì ì§€ í›„ë³´ ì„¸íŠ¸
    goals = set(station_to_nodes[goal_name])

    # (3) Dijkstra
    dist   = {SUPER: 0}
    parent = {SUPER: None}
    pq     = [(0, SUPER)]

    final_goal = None
    while pq:
        cost, u = heapq.heappop(pq)
        if u in goals:               # ê°€ìž¥ ë¨¼ì € êº¼ë‚¸ ëª©ì ì§€ == ìµœë‹¨
            final_goal = u
            break
        if cost > dist[u]:
            continue
        for w, v in graph[u]:
            nc = cost + w
            if v not in dist or nc < dist[v]:
                dist[v]   = nc
                parent[v] = u
                heapq.heappush(pq, (nc, v))

    if final_goal is None:
        return None, float('inf')

    # (4) ê²½ë¡œ ë³µì› (ìŠˆí¼ ì†ŒìŠ¤ ì œê±°)
    path = []
    cur = final_goal
    while cur and cur != SUPER:
        path.append(cur)
        cur = parent[cur]
    path.reverse()
    return path, dist[final_goal]

# -------------------------------------------------------------
# 5. CLI  â€“  ì—­ ì´ë¦„ë§Œ ìž…ë ¥
# -------------------------------------------------------------
if __name__ == "__main__":
    try:
        s_name = input("ì¶œë°œì—­ ì´ë¦„: ").strip()
        g_name = input("ë„ì°©ì—­ ì´ë¦„: ").strip()

        path, total = dijkstra_multi(graph, s_name, g_name)
        if path is None:
            print("âŒ ê²½ë¡œë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
        else:
            # â·  ê²½ë¡œ ë¬¸ìžì—´ì— êµ¬ê°„ë³„ ì‹œê°„ í¬í•¨
            pretty = []
            for i, (ln, st) in enumerate(path):
                if i == 0:
                    pretty.append(f"{ln}í˜¸ì„  {st}")
                else:
                    w = edge_time(graph, path[i-1], path[i])
                    pretty.append(f" --{w:.1f}ë¶„â†’ {ln}í˜¸ì„  {st}")

            txt = "".join(pretty)

            # â¸  ì¶œë ¥
            print(f"\n[ê²½ë¡œ]\n{txt}")
            print(f"\n[ì´ ì†Œìš” ì‹œê°„] {total:.1f}ë¶„  (í™˜ìŠ¹ {TRANSFER_TIME}ë¶„ í¬í•¨)")

    except Exception as e:
        print("âš ï¸ ì˜¤ë¥˜:", e)
